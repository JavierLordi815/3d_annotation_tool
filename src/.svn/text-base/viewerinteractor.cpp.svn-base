#include "viewerinteractor.h"
#include "mainwindow.h"

#include <qcoreapplication.h>

#include <pcl/common/angles.h>
#include <pcl/filters/project_inliers.h>
#include <pcl/common/transforms.h>

#include <eigen3/Eigen/Core>


#define PI 3.14159265

viewerInteractor::viewerInteractor():
    boundingBox (new pcl::PointCloud<pcl::PointXYZ>)
{
    // The color order is: red, green, blue, yellow, pink, turquoise, orange, purple,
    // dark green, beige, brown, gold, salmon, grey, blueViolet
    int cRed [15] = {  255,   0,   0, 255, 255,   0, 255, 128,   0, 255, 165, 139, 198, 84, 138};
    int cGreen [15] = {  0, 255,   0, 255,   0, 255, 160,  0, 128, 222, 42, 117, 113, 84, 43};
    int cBlue [15] = {   0,   0, 255,   0, 255, 255, 0  , 128,   0, 173, 42,  0, 113, 84, 226};

    for(int i=0; i<15; i++){
        colorRedValue.push_back(cRed[i]);
        colorGreenValue.push_back(cGreen[i]);
        colorBlueValue.push_back(cBlue[i]);
    }

    boundingBox->width  = 8;
    boundingBox->height = 1;
    boundingBox->points.resize (boundingBox->width * boundingBox->height);
}

void viewerInteractor::setViewer(boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer){
    _viewer = viewer;
}

int nPoints = 0;
bool picked(false);
pcl::PointXYZRGB pickedPoints;

// Callback function
void pp_callbacks (const pcl::visualization::PointPickingEvent& event, void* viewer_void){
    if (event.getPointIndex () == -1)
        return;

    // Get the point picked by the user
    event.getPoint(pickedPoints.x, pickedPoints.y, pickedPoints.z);
    nPoints++;
    picked=true;
}


void viewerInteractor::registerCallback(){
    _viewer->registerPointPickingCallback(pp_callbacks, (void*)&_viewer);
}


void viewerInteractor::getPointPicked(pcl::PointXYZRGB *point){
    picked = false;

    while(!picked){
        QCoreApplication::processEvents();
    }
    point->x=pickedPoints.x;
    point->y=pickedPoints.y;
    point->z=pickedPoints.z;
    picked = false;
}

void viewerInteractor::getPointsPicked(int nPoints, std::vector<pointT> *pointsPicked){
    for(int i=0; i<nPoints; i++){
        pcl::PointXYZRGB point;
        getPointPicked(&point);
        pointsPicked->push_back(point);
    }
}

void viewerInteractor::cleanViewer(){
    removeDrawnClouds();
    removeBoundingBox();
    //    _viewer->removeAllPointClouds();
    //    _viewer->resetCamera();
    //    _viewer->removeAllShapes();
}

void viewerInteractor::cleanAll(){
    _viewer->removeAllPointClouds();
    _viewer->resetCamera();
    _viewer->removeAllShapes();
}

void viewerInteractor::visualizePointCloud(pointCloudPtr cloud){
    pcl::visualization::PointCloudColorHandlerRGBField<pointT> rgb(cloud);
    _viewer->addPointCloud<pointT>(cloud,rgb);
    _viewer->setBackgroundColor(0, 0, 0);
    _viewer->addCoordinateSystem(0.5);
}


void viewerInteractor::highligthPoints(pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud,
                                       int r,
                                       int g,
                                       int b,
                                       pcl::PointIndices indices){

    removeDrawnClouds();

    pcl::PointCloud<pcl::PointXYZ>::Ptr cloudObject (new pcl::PointCloud<pcl::PointXYZ>);
    pcl::copyPointCloud(*cloud, indices, *cloudObject);

    pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> single_color(cloudObject, r, g, b);

    _listClouds.push_back("colored");
    _viewer->addPointCloud<pcl::PointXYZ> (cloudObject, single_color, _listClouds[0]);

}


void viewerInteractor::highligthPointsinBox(pointCloudPtr cloud){
    pcl::PointIndices indices;
    getPointsInBoundingBox(cloud, &indices);
    highligthPoints(cloud, 255, 0, 0, indices);
}


void viewerInteractor::highligthAllObjects(pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud, std::vector<object> &objectList){
    removeDrawnClouds();

    for(int i=0; i < objectList.size(); i++){

        pcl::PointCloud<pcl::PointXYZ>::Ptr cloudObject (new pcl::PointCloud<pcl::PointXYZ>);
        pcl::copyPointCloud(*cloud, objectList[i].indices, *cloudObject);

        pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> single_color(cloudObject,
                                                                                     colorRedValue.at(i),
                                                                                     colorGreenValue.at(i),
                                                                                     colorBlueValue.at(i));
        std::stringstream name; name << i;

        _listClouds.push_back(name.str());
        _viewer->addPointCloud<pcl::PointXYZ> (cloudObject, single_color, _listClouds[i]);
    }
}

void viewerInteractor::removeDrawnClouds(){
    if(_listClouds.size()!=0){
        for(int i = 0; i < _listClouds.size(); i++){
            _viewer->removePointCloud(_listClouds[i]);
        }
        _listClouds.clear();
    }
}

void viewerInteractor::removeCoordinateSystem(){
    _viewer->removeCoordinateSystem();
}

void viewerInteractor::addCoordinateSystem(){
    _viewer->addCoordinateSystem(0.5);
}

void viewerInteractor::defineBoundingBox(pcl::PointXYZ objectPose,
                                         float roll,
                                         float pitch,
                                         float yaw,
                                         float length,
                                         float width,
                                         float height){
    _pose = objectPose;
    _boxLength = length;
    _boxWidth = width;
    _boxHeight = height;
    _angleRoll = roll;
    _anglePitch = pitch;
    _angleYaw = yaw;

    // Fill in the cloud data
    // First point is the pose
    boundingBox->points[0].x = 0.0; boundingBox->points[0].y = 0.0; boundingBox->points[0].z = 0.0;


    // Calculate the other three points in the front face
    boundingBox->points[1].x = length; boundingBox->points[1].y = 0.0; boundingBox->points[1].z = 0.0;
    boundingBox->points[2].x = length; boundingBox->points[2].y = 0.0; boundingBox->points[2].z = height;
    boundingBox->points[3].x = 0.0; boundingBox->points[3].y = 0.0;  boundingBox->points[3].z = height;


    // Calculate the four points in the back face
    boundingBox->points[4].x = 0.0; boundingBox->points[4].y = width; boundingBox->points[4].z = 0.0;
    boundingBox->points[5].x = length; boundingBox->points[5].y = width; boundingBox->points[5].z = 0.0;
    boundingBox->points[6].x = length; boundingBox->points[6].y = width; boundingBox->points[6].z = height;
    boundingBox->points[7].x = 0.0; boundingBox->points[7].y = width; boundingBox->points[7].z = height;
}


void viewerInteractor::actualizeTransformation(){
    _transformation = pcl::getTransformation (_pose.x,
                                              _pose.y,
                                              _pose.z,
                                              _angleRoll,
                                              _anglePitch,
                                              _angleYaw);
}

void viewerInteractor::drawBoundingBox(){
    // Before drawing, remove the previous lines
    _viewer->removeAllShapes();

    // Auxiliar bounding box to apply the transformation
    pcl::PointCloud<pcl::PointXYZ>::Ptr boxAux (new pcl::PointCloud<pcl::PointXYZ>);
    actualizeTransformation();
    //    Eigen::Affine3f transformation = pcl::getTransformation (_pose.x,
    //                                                             _pose.y,
    //                                                             _pose.z,
    //                                                             _angleRoll,
    //                                                             _anglePitch,
    //                                                             _angleYaw);
    pcl::transformPointCloud(
                *boundingBox,
                *boxAux,
                _transformation);

    // Draw front face
    _viewer->addLine(boxAux->points[0], boxAux->points[1], 255, 0, 0, "0_1");
    _viewer->addLine(boxAux->points[0], boxAux->points[3], 255, 0, 0, "0_3");
    _viewer->addLine(boxAux->points[1], boxAux->points[2], 255, 0, 0, "1_2");
    _viewer->addLine(boxAux->points[2], boxAux->points[3], 255, 0, 0, "2_3");

    // Draw back face
    _viewer->addLine(boxAux->points[4], boxAux->points[5], 255, 255, 0, "4_5");
    _viewer->addLine(boxAux->points[4], boxAux->points[7], 255, 255, 0, "4_7");
    _viewer->addLine(boxAux->points[5], boxAux->points[6], 255, 255, 0, "5_6");
    _viewer->addLine(boxAux->points[6], boxAux->points[7], 255, 255, 0, "6_7");

    // Draw lines between faces
    _viewer->addLine(boxAux->points[0],boxAux->points[4], 255, 255, 0, "0_4");
    _viewer->addLine(boxAux->points[1], boxAux->points[5], 255, 255, 0, "1_5");
    _viewer->addLine(boxAux->points[2],boxAux->points[6], 255, 255, 0, "2_6");
    _viewer->addLine(boxAux->points[3], boxAux->points[7], 255, 255, 0, "3_7");
}

void viewerInteractor::getPointsInBoundingBox(pointCloudPtr cloud, pcl::PointIndices *indices){
    if(true){
        int nPoints = 0;
        pointCloudPtr cloudAux (new pointCloud);
        cloudAux->width = cloud->size();
        cloudAux->height = 1;
        cloudAux->resize(cloud->size());

        actualizeTransformation();

        //        Eigen::Affine3f transformation = pcl::getTransformation (_pose.x,
        //                                                                 _pose.y,
        //                                                                 _pose.z,
        //                                                                 _angleRoll,
        //                                                                 _anglePitch,
        //                                                                 _angleYaw);
        Eigen::Affine3f inverse = _transformation.inverse();
        pcl::transformPointCloud(
                    *cloud,
                    *cloudAux,
                    inverse);

        //        // Apply the translation
        //        Eigen::Affine3f transformation = pcl::getTransformation (-_pose.x, -_pose.y, -_pose.z, 0.0, 0.0, 0.0);
        //        pcl::transformPointCloud(
        //                    *cloud,
        //                    *cloudAux,
        //                    transformation);

        //        // Apply the rotation
        //        Eigen::Affine3f transformation2 = pcl::getTransformation (0.0, 0.0, 0.0, -_angleRoll, -_anglePitch, -_angleYaw);
        //        pcl::transformPointCloud(
        //                    *cloudAux,
        //                    *cloudAux,
        //                    transformation2);

        for(size_t index = 0; index < cloud->points.size(); index++){
            pcl::PointXYZ pointToCheck;
            pointToCheck .x = cloudAux->points[index].x;
            pointToCheck .y = cloudAux->points[index].y;
            pointToCheck .z = cloudAux->points[index].z;
            if (pointToCheck.x > 0 && pointToCheck.y > 0 && pointToCheck.z > 0
                    && pointToCheck.x < _boxLength && pointToCheck.y < _boxWidth && pointToCheck.z < _boxHeight){
                indices->indices.push_back(index);
                nPoints++;
            }
        }
    }


    //    Eigen::Affine3f transformation1 = pcl::getTransformation (-_pose.x, -_pose.y, -_pose.z, 0.0, 0.0, 0.0);
    //    Eigen::Affine3f transformation2 = pcl::getTransformation (0.0, 0.0, 0.0, -_angleRoll, -_anglePitch, -_angleYaw);

    //    for(size_t index = 0; index < cloud->points.size(); index++){
    //        pcl::PointXYZ pointToCheck;
    //        pointToCheck .x = cloud->points[index].x;
    //        pointToCheck .y = cloud->points[index].y;
    //        pointToCheck .z = cloud->points[index].z;
    //        pcl::transformPoint(pointToCheck, transformation1);
    //        pcl::transformPoint(pointToCheck, transformation2);
    //        if (pointToCheck.x > 0 && pointToCheck.y > 0 && pointToCheck.z > 0
    //                && pointToCheck.x < _boxLength && pointToCheck.y < _boxWidth && pointToCheck.z < _boxHeight){
    //            indices->indices.push_back(index);
    //            nPoints++;
    //        }
    //    }

}


void viewerInteractor::redefinePose(pcl::PointXYZ objectPose){
    _pose = objectPose;
}

void viewerInteractor::redefineRotation(float roll, float pitch, float yaw){
    _angleRoll = roll;
    _anglePitch = pitch;
    _angleYaw = yaw;
}

void viewerInteractor::redefineLength(float length){
    boundingBox->points[1].x = length;
    boundingBox->points[2].x = length;
    boundingBox->points[5].x = length;
    boundingBox->points[6].x = length;
    _boxLength = length;
}

void viewerInteractor::redefineWidth(float width){
    // Calculate the four points in the back face
    boundingBox->points[4].y = width;
    boundingBox->points[5].y = width;
    boundingBox->points[6].y = width;
    boundingBox->points[7].y = width;
    _boxWidth = width;
}

void viewerInteractor::redefineHeight(float height){
    boundingBox->points[2].z = height;
    boundingBox->points[3].z = height;
    boundingBox->points[6].z = height;
    boundingBox->points[7].z = height;
    _boxHeight = height;
}


void viewerInteractor::removeBoundingBox(){
    _viewer->removeAllShapes();
}
